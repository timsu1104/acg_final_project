#version 460
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_ray_tracing : enable
#extension GL_EXT_nonuniform_qualifier : enable
// clang-format off
#include "ray_payload.glsl"
#include "uniform_objects.glsl"
#include "material.glsl"
#include "constants.glsl"
// clang-format on

layout(binding = 0) uniform accelerationStructureEXT scene;
layout(binding = 1, rgba32f) uniform image2D accumulation_color;
layout(binding = 2, r32f) uniform image2D accumulation_number;
layout(binding = 3) uniform global_uniform_object {
  GlobalUniformObject guo;
};
layout(binding = 4) readonly buffer entity_array {
  EntityUniformObject entity_objects[];
};
layout(binding = 5) readonly buffer material_array {
  Material materials[];
};
layout(binding = 6) readonly buffer object_info_array {
  ObjectInfo object_infos[];
};
layout(binding = 7) readonly buffer vertex_array {
  float vertices[];
};
layout(binding = 8) readonly buffer index_array {
  uint indices[];
};
layout(binding = 9) uniform sampler2D[] texture_samplers;

layout(location = 0) rayPayloadEXT RayPayload ray_payload;

// clang-format off
#include "random.glsl"
#include "vertex.glsl"
#include "hit_record.glsl"
// clang-format on

vec3 SampleEnvmap(vec3 direction) {
  float x = guo.envmap_offset;
  float y = acos(direction.y) * INV_PI;
  if (length(vec2(direction.x, direction.y)) > 1e-4) {
    x += atan(direction.x, -direction.z);
  }
  x *= INV_PI * 0.5;
  return texture(texture_samplers[guo.envmap_id], vec2(x, y))
      .xyz;  // textures_[envmap_id_].Sample(glm::);
}

HitRecord hit_record;
void TraceRay(vec3 origin, vec3 direction) {
  float tmin = 1e-3;
  float tmax = 1e4;

  ray_payload.t = -1.0;
  ray_payload.barycentric = vec3(0.0);
  ray_payload.object_id = 0;
  ray_payload.primitive_id = 0;
  ray_payload.object_to_world = mat4x3(1.0);

  traceRayEXT(scene, gl_RayFlagsOpaqueEXT, 0xff, 0, 0, 0, origin, tmin,
              direction, tmax, 0);
  hit_record = GetHitRecord(ray_payload, origin, direction);
}

float color_refraction[] = {1.510, 1.523, 1.530, 1.535, 1.550, 1.565, 1.590};
vec3 color_albedo[] = {{1, 0, 0}, {1, 0.5, 0}, {1, 1, 0}, {0, 1, 0}, {0, 1, 1}, {0, 0, 1}, {0.5, 0, 0.5}};

// clang-format off
#include "pdf.glsl"
// clang-format on

float reflectance(float cosine, float ref_idx) {
  float r0 = (1.0 - ref_idx) / (1.0 + ref_idx);
  r0 = r0 * r0;
  return r0 + (1 - r0) * pow((1.0f - cosine), 5);
}

vec3 SampleRay(vec3 origin, vec3 direction) {
  vec3 radiance = vec3(0.0);
  vec3 throughput = vec3(1.0);
  vec3 l_dir = vec3(0.0);
  const float rate = 0.9;

  int light_idx;
  for (light_idx = 0; light_idx < materials.length(); light_idx++)
    if (materials[light_idx].material_type == MATERIAL_TYPE_EMISSION)
      break;

  for (int b = 0; b < guo.num_bounces; b++) {
    TraceRay(origin, direction);

    if (ray_payload.t == -1.0) {
      radiance += throughput * SampleEnvmap(direction);
      break;
    } else {
      Material material = materials[hit_record.hit_entity_id];
      if (material.material_type == MATERIAL_TYPE_EMISSION) {
        radiance += throughput * material.emission * material.emission_strength;
        break;
      }
      
      origin = hit_record.position;
      vec3 albedo = material.albedo_color;
      vec3 normal = hit_record.normal;
      if (dot(normal, direction) > 0.0) {
        normal = -normal;
      }
      
      if (material.material_type == MATERIAL_TYPE_LAMBERTIAN) {
        if (material.albedo_texture_id >= 0) {
          albedo *= vec3(texture(texture_samplers[material.albedo_texture_id],
                                   hit_record.tex_coord));
        }

        LightPdf light_sampler;
        light_sampler.index = light_idx;
        light_sampler.area = GetArea(light_idx);
        light_sampler.normal_ = normal;
        vec3 light_dir = Generate_Light(light_sampler, origin);
        if (light_dir != vec3(0.0)) {
          float light_pdf = Value_Light(light_sampler, origin, light_dir);
          vec3 light_color = materials[light_idx].emission * materials[light_idx].emission_strength;
          float scatter = max(0.0, dot(normal, direction) / PI);
          l_dir += 
            throughput
              * albedo
              * scatter
              * light_color
              / light_pdf;
        }

        CosineHemispherePdf brdf_sample;
        brdf_sample.uvw = Onb_from_z(normal);
        
        // Importance Sampling from Lambertian BRDF
        // direction = Generate_Cos(brdf_sample, origin);
        // float pdf = Value_Cos(brdf_sample, direction);
        
        // Importance Sampling from Light
        // direction = Generate_Light(light_sampler, origin);
        // if (direction == vec3(0.0))
        //   break;
        // float pdf = Value_Light(light_sampler, origin, direction);

        // Multiple Importance Sampling
        MixturePdf mixpdf;
        mixpdf.light_ = light_sampler;
        mixpdf.cosine_ = brdf_sample;
        mixpdf.prob = 0.1;
        direction = Generate_Mix(mixpdf, origin);
        if (direction == vec3(0.0))
          break;
        float pdf = Value_Mix(mixpdf, origin, direction);

        float scatter = max(0.0, dot(normal, direction) / PI);
        throughput *= albedo * scatter / pdf / rate;
      }

      if (material.material_type == MATERIAL_TYPE_SPECULAR) {
        direction = reflect(direction, hit_record.normal);
        throughput *= albedo;
      }

      if (material.material_type == MATERIAL_TYPE_TRANSMISSIVE) {
        uint color_index = RandomInt(7);
        float ir = color_refraction[color_index] * 0.7;
        float refraction_ratio = hit_record.front_face ?  (1.0 / ir) : ir;
        throughput *= albedo * color_albedo[color_index];
        if (dot(normal, direction) > 0.0) {
          normal = -normal;
        }
        float cosine = abs(dot(normal, direction) / (length(normal) * length(direction)));
        float sine = sqrt(1.0 - cosine * cosine);
        bool cannot_refract = refraction_ratio * sine > 1.0;
        if (cannot_refract || reflectance(cosine, refraction_ratio) > RandomFloat()) {
          direction = reflect(direction, normal);
        } else {
          direction = refract(direction, normal, refraction_ratio);
        }
      }

      if (RandomFloat() > rate || max(throughput.x, max(throughput.y, throughput. z)) < 1e-5) {
        break;
      }
      //  else {
      //   throughput *= material.albedo_color *
      //                 vec3(texture(texture_samplers[material.albedo_texture_id],
      //                              hit_record.tex_coord));
      //   origin = hit_record.position;
      //   direction = guo.envmap_light_direction;
      //   radiance += throughput * guo.envmap_minor_color;
      //   throughput *= max(dot(direction, hit_record.normal), 0.0) * 2.0;
      //   TraceRay(origin, direction);
      //   if (ray_payload.t < 0.0f) {
      //     radiance += throughput * guo.envmap_major_color;
      //   }
      //   break;
      // }
    }
  }
  radiance = l_dir + radiance;
  return radiance;
}

void main() {
  const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
  const vec2 inUV = pixelCenter / vec2(gl_LaunchSizeEXT.xy);
  vec2 d = inUV * 2.0 - 1.0;

  mat4 camera_to_world = inverse(guo.camera);
  mat4 screen_to_camera = inverse(guo.projection);

  for (int i = 0; i < guo.num_samples; i++) {
    InitRandomSeed(uint(pixelCenter.x), uint(pixelCenter.y),
                   guo.accumulated_sample + i);
    vec4 origin = camera_to_world * vec4(0, 0, 0, 1);
    vec4 target = screen_to_camera * vec4(d.x, d.y, 1, 1);
    vec4 direction = camera_to_world * vec4(normalize(target.xyz), 0);

    imageStore(accumulation_color, ivec2(gl_LaunchIDEXT.xy),
               imageLoad(accumulation_color, ivec2(gl_LaunchIDEXT.xy)) +
                   vec4(SampleRay(origin.xyz, direction.xyz), 1.0));
    imageStore(accumulation_number, ivec2(gl_LaunchIDEXT.xy),
               imageLoad(accumulation_number, ivec2(gl_LaunchIDEXT.xy)) + 1.0);
  }
}